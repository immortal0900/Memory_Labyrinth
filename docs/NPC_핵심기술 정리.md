---
생성날짜:
- 2026-01-03 04:50
마지막수정날짜:
- 2026-01-03-토요일 04:50
tags:
별칭:
type:
- 자료수집
Area/Reasource:
Project:
---

## NPC 시스템 기술 정리

---

## 1. 장기 메모리 시스템 (Mem0 대체)

### 선택 이유
| Mem0의 한계 | 자체 구축 필요성 |
|------------|-----------------|
| 메타데이터 부재로 화자/대상 구분 불가 | NPC가 유저 정보를 자신의 것으로 착각하는 할루시네이션 발생 |
| 벡터 유사도만 사용 | 최신성, 중요도, 키워드 일치 고려 불가 |
| 전체 대화 저장 | 불필요한 데이터 누적으로 검색 효율 저하 |

### 구현 방법
- **Fact 단위 저장**: 추후 누적될 데이터에서 효율적인 RAG 검색을 위해 전체 대화가 아닌 LLM이 추출한 핵심 사실(Fact)을 **주어+서술어+목적어(SPO) 형태**로 저장
- **메타데이터 구조화**: speaker(화자), subject(대상), content_type(취향/사건/평가), importance(중요도 1~10) 명시적 저장
- **중복 처리**: `valid_at`, `invalid_at`으로 기억의 중복처리

### 핵심 기능
- 대화에서 저장할 가치 있는 Fact만 선별 추출
- 화자/대상 명확히 구분하여 혼동 방지
- 취향 변화 시 기존 기억 무효화 (soft delete)

---

## 2. 하이브리드 검색 (4요소 스코어링)

### 선택 이유
| 단일 검색의 한계 | 하이브리드의 장점 |
|-----------------|------------------|
| 벡터만: "고양이" 검색 시 "강아지"도 높은 점수 | 키워드 일치로 정확도 보완 |
| 키워드만: 동의어, 유사 표현 검색 불가 | 벡터로 의미적 유사성 포착 |
| 오래된 기억도 동일 점수 | 최신성 가중치로 신선한 기억 우선 |

### 구현 방법
- **pgvector**: HNSW 인덱스로 코사인 유사도 기반 벡터 검색
- **PGroonga**: 한국어 형태소 분석 + BM25 알고리즘으로 키워드 검색
- **가중 합산**: 4가지 요소를 가중치로 조합하여 최종 스코어 계산
  - Recency 0.15 + Importance 0.15 + Relevance 0.50 + Keyword 0.20

### 핵심 기능
- 의미적 유사성과 키워드 정확도를 동시에 고려
- 최신 기억과 중요한 기억에 가산점 부여
- Raw SQL로 복잡한 스코어링 쿼리 직접 제어 (ORM 미사용)

---

## 3. 상위 키워드 확장

### 선택 이유
| 문제 | 해결 필요성 |
|------|------------|
| "사과 좋아해" 저장 후 "과일" 검색 시 못 찾음 | 상위 개념으로 검색 범위 확장 필요 |

### 구현 방법
- **LLM 키워드 추출**: Fact 추출 시 구체적 키워드 + 상위 카테고리 함께 추출
  - 예: "포도" → keywords: ["포도", "과일", "음식", "선호"]
- **임베딩 결합**: `"content (Keywords: 키워드1, 키워드2...)"` 형태로 결합 후 임베딩 생성
- **PGroonga 인덱스**: content + keywords 배열 함께 인덱싱하여 검색

### 핵심 기능
- 구체적 단어와 상위 개념 모두로 검색 가능
- 키워드 배열을 PGroonga로 검색하여 다양한 표현 매칭

---

## 4. 중복/충돌 감지

### 선택 이유
| 문제 | 해결 필요성 |
|------|------------|
| 같은 내용 반복 저장 | 불필요한 데이터 누적 |
| 취향 변화 미반영 | "사과 좋아해" → "사과 싫어해" 둘 다 유효하면 혼란 |

### 구현 방법
- **2단계 중복 검사**:
  - 90% 유사도 이상: 완전 중복으로 판단, 즉시 무효화
  - 55~90% 유사도 + 같은 content_type: LLM에게 충돌 여부 판단 요청
- **취향 변화 추적**: 충돌 판정 시 기존 기억에 `invalid_at` 설정

### 핵심 기능
- 임베딩 유사도로 1차 필터링 (빠른 처리)
- LLM으로 2차 판단 (정확한 충돌 감지)
- 기존 취향 무효화하여 최신 취향만 유효하게 유지

---

## 5. 단기 메모리 요약

### 선택 이유
| 기존 요약의 문제 | 해결 필요성 |
|----------------|------------|
| 모든 대화 요약 → 쓰레기 데이터 누적 | 선택적 요약으로 품질 유지 |
| 한번에 비우면 요약 없는 상태 발생 | 점진적 삭제로 연속성 유지 |

### 구현 방법
- **조건부 요약 생성**:
  - 10턴 이상: 첫 요약 생성
  - 20턴 이상 OR 1시간 경과: 추가 요약 생성
- **리스트 관리**: 시간순 리스트로 최대 5개 유지
- **중요도 기반 삭제**: 5개 초과 시 중요도 낮은 것부터 삭제, 단 최고 중요도는 1 감소 후 보존

### 핵심 기능
- 대화의 신선함(Freshness) 유지
- 중요한 맥락은 오래 보존
- 컨텍스트 창 낭비 방지

---

## 6. 시나리오 검색 정확도 향상

### 선택 이유
| 문제 | 원인 |
|------|------|
| scenario_inquiry로 분류되어도 엉뚱한 시나리오 반환 | 질문과 시나리오 데이터의 벡터 유사도가 낮음 |

### 구현 방법
- **메타데이터 확장**: 시나리오 데이터에 검색용 키워드/동의어 추가
  - 예: title, keywords, synonyms 컬럼 추가
- **하이브리드 검색 적용**: 시나리오 테이블에도 pgvector + PGroonga 검색 적용
- **memory_progress 기반 필터**: 해금된 진척도 범위 내에서만 검색

### 핵심 기능
- 다양한 표현의 질문에도 정확한 시나리오 매칭
- 해금되지 않은 시나리오는 검색 대상에서 제외

---

## 7. 꼬리물기 질문 대응

### 선택 이유
| 문제 | 원인 |
|------|------|
| "그때 숲에 왜 갔어?" → general로 분류됨 | 의도 분류 시 요약만 참조하여 구체적 맥락 없음 |
| newly_unlocked_scenario가 현재 턴에서만 유효 | 다음 턴에서 해금된 기억 추적 불가 |

### 구현 방법
- **최근 3턴 대화 직접 주입**: 의도 분류 프롬프트에 요약 대신 실제 대화 3턴 포함
- **recently_unlocked_memory 상태 유지**: 해금된 기억 정보를 5턴 동안 TTL로 유지
- **지시어 인식 강화**: "그때", "그거", "방금 말한 거" 등이 최근 해금 기억을 가리키면 scenario_inquiry로 분류

### 핵심 기능
- 지시어가 최근 NPC 발화의 기억/과거를 가리키면 시나리오로 분류
- 해금 직후 5턴까지 관련 꼬리질문에 정확히 대응

---

## 8. 응답 시간 최적화

### 선택 이유
| 문제 | 목표 |
|------|------|
| 응답 시간 3초 초반대 | 2~3초대로 단축 |

### 구현 방법
- **검색 파이프라인 최적화**: 의도 분류 결과에 따라 필요한 검색만 수행
- **비동기 백그라운드 저장**: 응답 반환 후 DB 저장(장기 메모리, 체크포인트)은 백그라운드 태스크로 처리
- **프롬프트 토큰 최적화**: 의도분류 `max_tokens=20`, 응답생성 `max_tokens=200` 제한
- **동적 프롬프트**: 필요한 컨텍스트만 선택적으로 프롬프트에 삽입

### 핵심 기능
- LLM 호출 횟수 최소화 (의도분류 1회 + 응답생성 1회)
- 불필요한 검색 생략으로 지연 감소
- 응답 우선 반환, 저장은 후처리

---

## 9. 프롬프트 실패 조건 기재

### 선택 이유
| 문제 | 원인 |
|------|------|
| NPC가 이전 대화 내용을 그대로 카피 | 새로 해금된 기억인지 인지 못함 |

### 구현 방법
- **실패 조건 명시**: 프롬프트에 "절대 하지 말아야 할 것" 섹션 추가
  - 예: "이전에 말한 내용을 그대로 반복하지 마세요"
  - 예: "해금되지 않은 기억에 대해 말하지 마세요"
- **해금 상태 명시**: 현재 memoryProgress와 접근 가능한 시나리오 범위를 프롬프트에 포함

### 핵심 기능
- LLM이 해금 여부를 인지하고 적절히 답변
- 반복적이거나 부적절한 응답 방지

---

## 10. NPC-NPC 대화 인터럽트

### 선택 이유
| 요구사항 | 필요성 |
|---------|--------|
| User가 NPC간 대화에 끼어들 때 | 중단 시점 이후 대화는 "일어나지 않은 일"로 처리 |

### 구현 방법
- **interruptedTurn 기록**: User 개입 시점의 턴 번호 저장
- **3단계 무효화**:
  1. 체크포인트 자르기: `npc_npc_checkpoints`에서 해당 턴 이후 삭제
  2. 장기기억 무효화: `npc_npc_memories`에서 해당 턴 이후 `invalid_at` 설정
  3. Redis 세션 자르기: 대화 버퍼에서 해당 턴 이후 삭제

### 핵심 기능
- "방금 쟤랑 무슨 얘기 했어?" 질문 시 중단 시점까지만 요약 답변
- 미래 대화 내용이 기억에 남지 않음

---

## 요약 테이블

| 기술/기능            | 선택 이유            | 구현 방법                        | 핵심 기능              |
| ---------------- | ---------------- | ---------------------------- | ------------------ |
| **장기 메모리**       | Mem0 메타데이터/검색 한계 | Fact 단위 저장 + 메타데이터 구조화       | 화자/대상 구분, 취향 변화 추적 |
| **하이브리드 검색**     | 벡터/키워드 단독의 한계    | pgvector + PGroonga 4요소 스코어링 | 정확도와 유연성 동시 확보     |
| **상위 키워드**       | 구체→추상 검색 불가      | LLM이 상위 카테고리 함께 추출           | 다양한 표현으로 검색 가능     |
| **중복 감지**        | 데이터 누적/취향 충돌     | 유사도 2단계 검사 + LLM 판단          | 최신 정보만 유효하게 유지     |
| **단기 메모리 요약**    | 쓰레기 데이터 누적       | 조건부 생성 + 중요도 기반 삭제           | 신선함과 중요 맥락 유지      |
| **시나리오 검색**      | 질문-시나리오 유사도 낮음   | 메타데이터 확장 + 하이브리드 검색          | 다양한 질문에 정확한 매칭     |
| **꼬리물기 대응**      | 지시어 맥락 파악 불가     | 최근 3턴 주입 + 해금 기억 5턴 유지       | 연속적인 대화 흐름 지원      |
| **응답 최적화**       | 3초대 응답 시간        | 비동기 저장 + 토큰 제한 + 동적 프롬프트     | 2~3초대로 단축          |
| **실패 조건 기재**     | 기억 해금 미인지        | 프롬프트에 금지 사항 명시               | 부적절한 응답 방지         |
| **NPC-NPC 인터럽트** | User 개입 처리       | 3단계 무효화 (DB + 메모리 + 세션)      | 중단 시점 기준 일관성 유지    |